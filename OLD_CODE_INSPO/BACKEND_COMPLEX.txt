##### OLD CODE -- BACKEND ######

+++ This is the backend code for a project was originally scaffolded with the Teams Toolkit, which introduced unnecessary complexity, dead weight, and tightly-coupled abstractions we don't need. What you're seeing now includes leftover config files, redundant state management, and extra wrappers that are being phased out. We're actively refactoring toward a clean, minimal setup: standalone React frontend, FastAPI backend, and a dead-simple Teams manifestâ€”no toolkit, no magic, no BS. +++



__init__.py
```py
# Azure Functions API Package
# This package contains all serverless endpoints for the 401k Payment Tracking System
```

.funcignore
```funcignore
*.pyc
__pycache__/
.python_packages/
.venv/
.vscode/
.git/
.gitignore
local.settings.json
tests/
README.md
.funcignore
.env*
*.md
```

calculations\__init__.py
```py
"""
Azure Function for variance calculations.
Compares actual vs expected fees.
"""
import azure.functions as func
import json

async def main(req: func.HttpRequest) -> func.HttpResponse:
    """
    Calculate variance between actual and expected fees.
    Route: GET /api/calculations/variance?actual_fee={amount}&expected_fee={amount}
    """
    try:
        actual = float(req.params.get('actual_fee', 0))
        expected = float(req.params.get('expected_fee', 0))
    except (ValueError, TypeError):
        return func.HttpResponse(
            json.dumps({"error": "Invalid fee amounts"}),
            status_code=400,
            mimetype="application/json"
        )
    
    if expected == 0:
        return func.HttpResponse(
            json.dumps({
                "status": "unknown",
                "message": "N/A",
                "difference": None,
                "percent_difference": None
            }),
            mimetype="application/json"
        )
    
    difference = actual - expected
    percent_diff = (difference / expected) * 100
    
    # Determine status based on percentage difference
    if abs(difference) < 0.01:
        status = "exact"
        message = "Exact Match"
    elif abs(percent_diff) <= 5:
        status = "acceptable"
        message = f"${difference:,.2f} ({percent_diff:.1f}%)"
    elif abs(percent_diff) <= 15:
        status = "warning"
        message = f"${difference:,.2f} ({percent_diff:.1f}%)"
    else:
        status = "alert"
        message = f"${difference:,.2f} ({percent_diff:.1f}%)"
    
    return func.HttpResponse(
        json.dumps({
            "status": status,
            "message": message,
            "difference": difference,
            "percent_difference": percent_diff
        }),
        mimetype="application/json"
    )
```

calculations\function.json
```json
{
  "scriptFile": "__init__.py",
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get"],
      "route": "calculations/variance"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "$return"
    }
  ]
}
```

clients\__init__.py
```py
# api/clients/__init__.py

"""
Azure Function for managing client endpoints.
Wraps existing database layer for serverless deployment.
"""
import azure.functions as func
import json
import sys
import os
from typing import Dict, Any

# Add backend to path to use existing database code
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from database.database import get_db
from database.models import Client, ClientCreate, ClientUpdate


async def main(req: func.HttpRequest) -> func.HttpResponse:
    """
    Handle client-related HTTP requests.
    
    Routes:
    - GET /api/clients - List all clients
    - GET /api/clients/{id} - Get specific client
    - POST /api/clients - Create new client
    - PUT /api/clients/{id} - Update client
    - DELETE /api/clients/{id} - Soft delete client
    """
    
    # Get client ID from route if present
    client_id = req.route_params.get('id')
    
    try:
        db = get_db()
        
        # GET all clients
        if req.method == "GET" and not client_id:
            # Get query parameters
            provider = req.params.get('provider')
            
            with db.cursor(commit=False) as cursor:
                query = """
                    SELECT c.client_id, c.display_name, c.full_name, 
                           c.ima_signed_date, c.onedrive_folder_path,
                           c.valid_from, c.valid_to,
                           co.provider_name,
                           m.last_payment_date, m.last_payment_amount,
                           m.last_recorded_assets, m.total_ytd_payments
                    FROM clients c
                    LEFT JOIN contracts co ON c.client_id = co.client_id 
                        AND co.valid_to IS NULL
                    LEFT JOIN client_metrics m ON c.client_id = m.client_id
                    WHERE c.valid_to IS NULL
                """
                
                params = []
                if provider:
                    query += " AND co.provider_name = ?"
                    params.append(provider)
                
                query += " ORDER BY c.display_name"
                
                if params:
                    cursor.execute(query, params)
                else:
                    cursor.execute(query)
                    
                columns = [column[0] for column in cursor.description]
                rows = cursor.fetchall()
            
            # Convert to list of dictionaries
            clients = []
            for row in rows:
                client_dict = dict(zip(columns, row))
                clients.append(client_dict)
            
            return func.HttpResponse(
                json.dumps(clients, default=str),
                mimetype="application/json"
            )
        
        # GET single client
        elif req.method == "GET" and client_id:
            with db.cursor(commit=False) as cursor:
                query = """
                    SELECT c.client_id, c.display_name, c.full_name,
                           c.ima_signed_date, c.onedrive_folder_path,
                           c.valid_from, c.valid_to,
                           co.provider_name, co.fee_type, co.payment_schedule,
                           m.last_payment_date, m.last_payment_amount,
                           m.total_ytd_payments, m.avg_quarterly_payment,
                           m.last_recorded_assets, m.next_payment_due
                    FROM clients c
                    LEFT JOIN contracts co ON c.client_id = co.client_id 
                        AND co.valid_to IS NULL
                    LEFT JOIN client_metrics m ON c.client_id = m.client_id
                    WHERE c.client_id = ? AND c.valid_to IS NULL
                """
                cursor.execute(query, [int(client_id)])
                columns = [column[0] for column in cursor.description]
                row = cursor.fetchone()
            
            if not row:
                return func.HttpResponse(
                    json.dumps({"error": "Client not found"}),
                    status_code=404,
                    mimetype="application/json"
                )
            
            client_dict = dict(zip(columns, row))
            
            return func.HttpResponse(
                json.dumps(client_dict, default=str),
                mimetype="application/json"
            )
        
        # POST - Create new client
        elif req.method == "POST":
            try:
                req_body = req.get_json()
                client_create = ClientCreate(**req_body)
            except (ValueError, TypeError) as e:
                return func.HttpResponse(
                    json.dumps({"error": f"Invalid request body: {str(e)}"}),
                    status_code=400,
                    mimetype="application/json"
                )
            
            with db.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO clients (display_name, full_name, ima_signed_date, 
                                       onedrive_folder_path)
                    OUTPUT INSERTED.client_id
                    VALUES (?, ?, ?, ?)
                """, (
                    client_create.display_name,
                    client_create.full_name,
                    client_create.ima_signed_date,
                    client_create.onedrive_folder_path
                ))
                new_id = cursor.fetchone()[0]
            
            return func.HttpResponse(
                json.dumps({"client_id": new_id, **client_create.model_dump()}, default=str),
                mimetype="application/json",
                status_code=201
            )
        
        # PUT - Update client
        elif req.method == "PUT" and client_id:
            try:
                req_body = req.get_json()
                client_update = ClientUpdate(**req_body)
            except (ValueError, TypeError) as e:
                return func.HttpResponse(
                    json.dumps({"error": f"Invalid request body: {str(e)}"}),
                    status_code=400,
                    mimetype="application/json"
                )
            
            # Build dynamic update query
            update_fields = []
            params = []
            
            update_data = client_update.model_dump(exclude_unset=True)
            if not update_data:
                return func.HttpResponse(
                    json.dumps({"error": "No fields to update"}),
                    status_code=400,
                    mimetype="application/json"
                )
            
            for field, value in update_data.items():
                update_fields.append(f"{field} = ?")
                params.append(value)
            
            params.append(int(client_id))
            
            with db.cursor() as cursor:
                query = f"""
                    UPDATE clients 
                    SET {', '.join(update_fields)}
                    WHERE client_id = ? AND valid_to IS NULL
                """
                cursor.execute(query, params)
                
                if cursor.rowcount == 0:
                    return func.HttpResponse(
                        json.dumps({"error": "Client not found"}),
                        status_code=404,
                        mimetype="application/json"
                    )
            
            return func.HttpResponse(
                json.dumps({"message": "Client updated successfully"}),
                mimetype="application/json"
            )
        
        # DELETE - Soft delete client
        elif req.method == "DELETE" and client_id:
            with db.cursor() as cursor:
                cursor.execute("""
                    UPDATE clients 
                    SET valid_to = GETDATE()
                    WHERE client_id = ? AND valid_to IS NULL
                """, [int(client_id)])
                
                if cursor.rowcount == 0:
                    return func.HttpResponse(
                        json.dumps({"error": "Client not found"}),
                        status_code=404,
                        mimetype="application/json"
                    )
            
            return func.HttpResponse(status_code=204)
        
        # Method not allowed
        else:
            return func.HttpResponse(
                json.dumps({"error": "Method not allowed"}),
                status_code=405,
                mimetype="application/json"
            )
            
    except Exception as e:
        return func.HttpResponse(
            json.dumps({"error": str(e)}),
            status_code=500,
            mimetype="application/json"
        )
```

clients\function.json
```json
{
  "scriptFile": "__init__.py",
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get", "post", "put", "delete"],
      "route": "clients/{id?}"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "$return"
    }
  ]
}
```

contracts-by-client\function.json
```json
{
  "scriptFile": "../contracts/__init__.py",
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get"],
      "route": "contracts/client/{client_id}"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "$return"
    }
  ]
}
```

contracts\__init__.py
```py
# api/contracts/__init__.py


"""
Azure Function for managing contract endpoints.
Handles contract CRUD operations.
"""
import azure.functions as func
import json
import sys
import os

# Add backend to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from database.database import get_db
from database.models import Contract, ContractCreate, ContractUpdate


async def main(req: func.HttpRequest) -> func.HttpResponse:
    """
    Handle contract-related HTTP requests.
    
    Routes:
    - GET /api/contracts - List all contracts
    - GET /api/contracts/{id} - Get specific contract
    - GET /api/contracts/client/{client_id} - Get contract for a client
    - POST /api/contracts - Create new contract
    - PUT /api/contracts/{id} - Update contract
    - DELETE /api/contracts/{id} - Soft delete contract
    """
    
    contract_id = req.route_params.get('id')
    client_id = req.route_params.get('client_id')
    
    try:
        db = get_db()
        
        # GET all contracts
        if req.method == "GET" and not contract_id and not client_id:
            provider = req.params.get('provider')
            
            with db.cursor(commit=False) as cursor:
                query = """
                    SELECT co.*, c.display_name as client_name
                    FROM contracts co
                    JOIN clients c ON co.client_id = c.client_id
                    WHERE co.valid_to IS NULL
                """
                
                params = []
                if provider:
                    query += " AND co.provider_name = ?"
                    params.append(provider)
                
                query += " ORDER BY c.display_name"
                
                if params:
                    cursor.execute(query, params)
                else:
                    cursor.execute(query)
                
                columns = [column[0] for column in cursor.description]
                rows = cursor.fetchall()
            
            contracts = [dict(zip(columns, row)) for row in rows]
            
            return func.HttpResponse(
                json.dumps(contracts, default=str),
                mimetype="application/json"
            )
        
        # GET contract by client_id
        elif req.method == "GET" and client_id:
            with db.cursor(commit=False) as cursor:
                cursor.execute("""
                    SELECT co.*, c.display_name as client_name
                    FROM contracts co
                    JOIN clients c ON co.client_id = c.client_id
                    WHERE co.client_id = ? AND co.valid_to IS NULL
                """, [int(client_id)])
                
                columns = [column[0] for column in cursor.description]
                row = cursor.fetchone()
            
            if not row:
                return func.HttpResponse(
                    json.dumps({"error": "Contract not found for this client"}),
                    status_code=404,
                    mimetype="application/json"
                )
            
            contract = dict(zip(columns, row))
            
            return func.HttpResponse(
                json.dumps(contract, default=str),
                mimetype="application/json"
            )
        
        # GET single contract by id
        elif req.method == "GET" and contract_id:
            with db.cursor(commit=False) as cursor:
                cursor.execute("""
                    SELECT co.*, c.display_name as client_name
                    FROM contracts co
                    JOIN clients c ON co.client_id = c.client_id
                    WHERE co.contract_id = ? AND co.valid_to IS NULL
                """, [int(contract_id)])
                
                columns = [column[0] for column in cursor.description]
                row = cursor.fetchone()
            
            if not row:
                return func.HttpResponse(
                    json.dumps({"error": "Contract not found"}),
                    status_code=404,
                    mimetype="application/json"
                )
            
            contract = dict(zip(columns, row))
            
            return func.HttpResponse(
                json.dumps(contract, default=str),
                mimetype="application/json"
            )
        
        # POST - Create new contract
        elif req.method == "POST":
            try:
                req_body = req.get_json()
                contract_create = ContractCreate(**req_body)
            except (ValueError, TypeError) as e:
                return func.HttpResponse(
                    json.dumps({"error": f"Invalid request body: {str(e)}"}),
                    status_code=400,
                    mimetype="application/json"
                )
            
            with db.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO contracts (
                        client_id, contract_number, provider_name, contract_start_date,
                        fee_type, percent_rate, flat_rate, payment_schedule,
                        num_people, notes
                    )
                    OUTPUT INSERTED.contract_id
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    contract_create.client_id,
                    contract_create.contract_number,
                    contract_create.provider_name,
                    contract_create.contract_start_date,
                    contract_create.fee_type,
                    contract_create.percent_rate,
                    contract_create.flat_rate,
                    contract_create.payment_schedule,
                    contract_create.num_people,
                    contract_create.notes
                ))
                new_id = cursor.fetchone()[0]
            
            return func.HttpResponse(
                json.dumps({"contract_id": new_id, **contract_create.model_dump()}, default=str),
                mimetype="application/json",
                status_code=201
            )
        
        # PUT - Update contract
        elif req.method == "PUT" and contract_id:
            try:
                req_body = req.get_json()
                contract_update = ContractUpdate(**req_body)
            except (ValueError, TypeError) as e:
                return func.HttpResponse(
                    json.dumps({"error": f"Invalid request body: {str(e)}"}),
                    status_code=400,
                    mimetype="application/json"
                )
            
            # Build dynamic update query
            update_fields = []
            params = []
            
            update_data = contract_update.model_dump(exclude_unset=True)
            if not update_data:
                return func.HttpResponse(
                    json.dumps({"error": "No fields to update"}),
                    status_code=400,
                    mimetype="application/json"
                )
            
            for field, value in update_data.items():
                update_fields.append(f"{field} = ?")
                params.append(value)
            
            params.append(int(contract_id))
            
            with db.cursor() as cursor:
                query = f"""
                    UPDATE contracts 
                    SET {', '.join(update_fields)}
                    WHERE contract_id = ? AND valid_to IS NULL
                """
                cursor.execute(query, params)
                
                if cursor.rowcount == 0:
                    return func.HttpResponse(
                        json.dumps({"error": "Contract not found"}),
                        status_code=404,
                        mimetype="application/json"
                    )
            
            return func.HttpResponse(
                json.dumps({"message": "Contract updated successfully"}),
                mimetype="application/json"
            )
        
        # DELETE - Soft delete contract
        elif req.method == "DELETE" and contract_id:
            with db.cursor() as cursor:
                cursor.execute("""
                    UPDATE contracts 
                    SET valid_to = GETDATE()
                    WHERE contract_id = ? AND valid_to IS NULL
                """, [int(contract_id)])
                
                if cursor.rowcount == 0:
                    return func.HttpResponse(
                        json.dumps({"error": "Contract not found"}),
                        status_code=404,
                        mimetype="application/json"
                    )
            
            return func.HttpResponse(status_code=204)
        
        else:
            return func.HttpResponse(
                json.dumps({"error": "Method not allowed"}),
                status_code=405,
                mimetype="application/json"
            )
            
    except Exception as e:
        return func.HttpResponse(
            json.dumps({"error": str(e)}),
            status_code=500,
            mimetype="application/json"
        )
```

contracts\function.json
```json
{
  "scriptFile": "__init__.py",
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get", "post", "put", "delete"],
      "route": "contracts/{id?}"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "$return"
    }
  ]
}
```

dashboard\__init__.py
```py
"""
Azure Function for client dashboard data.
Leverages database views and new schema for aggregated client information.
"""
import azure.functions as func
import json
import sys
import os
from datetime import datetime

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
from database.database import get_db

async def main(req: func.HttpRequest) -> func.HttpResponse:
    """
    Get comprehensive dashboard data for a client.
    Route: GET /api/dashboard/{client_id}
    
    Returns:
    - Client information
    - Contract details  
    - Payment status (from view)
    - Recent payments
    - Compliance status
    - Summary metrics
    """
    client_id = req.route_params.get('client_id')
    
    if not client_id:
        return func.HttpResponse(
            json.dumps({"error": "client_id required"}),
            status_code=400,
            mimetype="application/json"
        )
    
    try:
        db = get_db()
        dashboard_data = {}
        
        with db.cursor(commit=False) as cursor:
            # Get client and contract data
            cursor.execute("""
                SELECT c.client_id, c.display_name, c.full_name, c.ima_signed_date,
                       c.onedrive_folder_path,
                       co.contract_id, co.provider_name, co.fee_type, 
                       co.percent_rate, co.flat_rate, co.payment_schedule,
                       m.last_payment_date, m.last_payment_amount,
                       m.total_ytd_payments, m.avg_quarterly_payment,
                       m.last_recorded_assets, m.next_payment_due
                FROM clients c
                LEFT JOIN contracts co ON c.client_id = co.client_id 
                    AND co.valid_to IS NULL
                LEFT JOIN client_metrics m ON c.client_id = m.client_id
                WHERE c.client_id = ? AND c.valid_to IS NULL
            """, [int(client_id)])
            
            columns = [column[0] for column in cursor.description]
            row = cursor.fetchone()
            
            if not row:
                return func.HttpResponse(
                    json.dumps({"error": "Client not found"}),
                    status_code=404,
                    mimetype="application/json"
                )
            
            client_data = dict(zip(columns, row))
            
            # Build client info
            dashboard_data['client'] = {
                'client_id': client_data['client_id'],
                'display_name': client_data['display_name'],
                'full_name': client_data['full_name'],
                'ima_signed_date': client_data['ima_signed_date'],
                'onedrive_folder_path': client_data['onedrive_folder_path']
            }
            
            # Build contract info
            if client_data['contract_id']:
                dashboard_data['contract'] = {
                    'contract_id': client_data['contract_id'],
                    'provider_name': client_data['provider_name'],
                    'fee_type': client_data['fee_type'],
                    'percent_rate': client_data['percent_rate'],
                    'flat_rate': client_data['flat_rate'],
                    'payment_schedule': client_data['payment_schedule']
                }
            else:
                dashboard_data['contract'] = None
            
            # Get payment status from view
            cursor.execute("""
                SELECT client_id, display_name, payment_schedule, fee_type,
                       flat_rate, percent_rate, last_payment_date, last_payment_amount,
                       applied_period, applied_year, applied_period_type,
                       current_period, current_year, last_recorded_assets,
                       expected_fee, payment_status
                FROM client_payment_status
                WHERE client_id = ?
            """, [int(client_id)])
            
            status_columns = [column[0] for column in cursor.description]
            status_row = cursor.fetchone()
            
            if status_row:
                status_data = dict(zip(status_columns, status_row))
                
                # Format current period name
                if status_data['applied_period_type'] == 'monthly':
                    months = ['January', 'February', 'March', 'April', 'May', 'June',
                             'July', 'August', 'September', 'October', 'November', 'December']
                    current_period_name = f"{months[status_data['current_period']-1]} {status_data['current_year']}"
                else:
                    current_period_name = f"Q{status_data['current_period']} {status_data['current_year']}"
                
                dashboard_data['payment_status'] = {
                    'status': status_data['payment_status'],
                    'current_period': current_period_name,
                    'current_period_number': status_data['current_period'],
                    'current_year': status_data['current_year'],
                    'last_payment_date': status_data['last_payment_date'],
                    'last_payment_amount': status_data['last_payment_amount'],
                    'expected_fee': status_data['expected_fee']
                }
                
                # Simple green/yellow compliance - no red
                if status_data['payment_status'] == 'Paid':
                    dashboard_data['compliance'] = {
                        'status': 'compliant',
                        'color': 'green',
                        'reason': 'Current period paid'
                    }
                else:  # 'Due'
                    dashboard_data['compliance'] = {
                        'status': 'compliant',
                        'color': 'yellow', 
                        'reason': f'Awaiting {current_period_name} payment'
                    }
            else:
                dashboard_data['payment_status'] = {
                    'status': 'Due',
                    'current_period': None,
                    'reason': 'No payment history'
                }
                dashboard_data['compliance'] = {
                    'status': 'compliant',
                    'color': 'yellow',
                    'reason': 'No payment history'
                }
            
            # Get recent payments
            cursor.execute("""
                SELECT TOP 5 
                    p.payment_id, p.received_date, p.actual_fee, p.total_assets,
                    p.applied_period, p.applied_year, p.applied_period_type,
                    CASE WHEN COUNT(pf.file_id) > 0 THEN 1 ELSE 0 END as has_files
                FROM payments p
                LEFT JOIN payment_files pf ON p.payment_id = pf.payment_id
                WHERE p.client_id = ? AND p.valid_to IS NULL
                GROUP BY p.payment_id, p.received_date, p.actual_fee, p.total_assets,
                         p.applied_period, p.applied_year, p.applied_period_type
                ORDER BY p.received_date DESC
            """, [int(client_id)])
            
            payment_columns = [column[0] for column in cursor.description]
            recent_payments = []
            
            for payment_row in cursor.fetchall():
                payment_dict = dict(zip(payment_columns, payment_row))
                
                # Format period display
                if payment_dict['applied_period_type'] == 'monthly':
                    months = ['January', 'February', 'March', 'April', 'May', 'June',
                             'July', 'August', 'September', 'October', 'November', 'December']
                    payment_dict['period_display'] = f"{months[payment_dict['applied_period']-1]} {payment_dict['applied_year']}"
                else:
                    payment_dict['period_display'] = f"Q{payment_dict['applied_period']} {payment_dict['applied_year']}"
                
                recent_payments.append(payment_dict)
            
            dashboard_data['recent_payments'] = recent_payments
            
            # Add metrics
            dashboard_data['metrics'] = {
                'total_ytd_payments': client_data['total_ytd_payments'],
                'avg_quarterly_payment': client_data['avg_quarterly_payment'], 
                'last_recorded_assets': client_data['last_recorded_assets'],
                'next_payment_due': client_data['next_payment_due']
            }
            
            # Get quarterly summaries for current year
            current_year = datetime.now().year
            cursor.execute("""
                SELECT quarter, total_payments, payment_count, avg_payment, expected_total
                FROM quarterly_summaries
                WHERE client_id = ? AND year = ?
                ORDER BY quarter
            """, [int(client_id), current_year])
            
            quarterly_columns = [column[0] for column in cursor.description]
            quarterly_summaries = []
            
            for q_row in cursor.fetchall():
                quarterly_summaries.append(dict(zip(quarterly_columns, q_row)))
            
            dashboard_data['quarterly_summaries'] = quarterly_summaries
        
        return func.HttpResponse(
            json.dumps(dashboard_data, default=str),
            mimetype="application/json"
        )
        
    except Exception as e:
        return func.HttpResponse(
            json.dumps({"error": str(e)}),
            status_code=500,
            mimetype="application/json"
        )
```

dashboard\function.json
```json
{
  "scriptFile": "__init__.py",
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get"],
      "route": "dashboard/{client_id}"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "$return"
    }
  ]
}
```

database\__init__.py
```py
"""
Database module for Azure SQL Database connection management.

This module provides a singleton database instance with context managers
for safe connection and cursor management.
"""

from .database import db, Database, get_db, DatabaseNotInitializedError

__all__ = ['db', 'Database', 'get_db', 'DatabaseNotInitializedError']
```

database\database_schema_dump.txt
```txt
=== TABLES ===


--- client_files ---
  - file_id: int(10) [PRIMARY KEY, NOT NULL]
  - client_id: int(10) [FK -> clients.client_id, NOT NULL]
  - file_name: nvarchar(255) [NOT NULL]
  - onedrive_path: nvarchar(500) [NOT NULL]
  - uploaded_at: datetime [DEFAULT (getdate())]

--- client_metrics ---
  - id: int(10) [PRIMARY KEY, NOT NULL]
  - client_id: int(10) [FK -> clients.client_id, NOT NULL]
  - last_payment_date: nvarchar(50)
  - last_payment_amount: float(53)
  - last_payment_quarter: int(10)
  - last_payment_year: int(10)
  - total_ytd_payments: float(53)
  - avg_quarterly_payment: float(53)
  - last_recorded_assets: float(53)
  - last_updated: nvarchar(50)
  - next_payment_due: nvarchar(50)

--- clients ---
  - client_id: int(10) [PRIMARY KEY, NOT NULL]
  - display_name: nvarchar(255) [NOT NULL]
  - full_name: nvarchar(255)
  - ima_signed_date: nvarchar(50)
  - onedrive_folder_path: nvarchar(500)
  - valid_from: datetime [DEFAULT (getdate())]
  - valid_to: datetime

--- contacts ---
  - contact_id: int(10) [PRIMARY KEY, NOT NULL]
  - client_id: int(10) [FK -> clients.client_id, NOT NULL]
  - contact_type: nvarchar(50) [NOT NULL]
  - contact_name: nvarchar(255)
  - phone: nvarchar(50)
  - email: nvarchar(255)
  - fax: nvarchar(50)
  - physical_address: nvarchar(500)
  - mailing_address: nvarchar(500)
  - valid_from: datetime [DEFAULT (getdate())]
  - valid_to: datetime

--- contracts ---
  - contract_id: int(10) [PRIMARY KEY, NOT NULL]
  - client_id: int(10) [FK -> clients.client_id, NOT NULL]
  - contract_number: nvarchar(100)
  - provider_name: nvarchar(255)
  - contract_start_date: nvarchar(50)
  - fee_type: nvarchar(50)
  - percent_rate: float(53)
  - flat_rate: float(53)
  - payment_schedule: nvarchar(50)
  - num_people: int(10)
  - notes: nvarchar(-1)
  - valid_from: datetime [DEFAULT (getdate())]
  - valid_to: datetime

--- payment_files ---
  - payment_id: int(10) [PRIMARY KEY, FK -> payments.payment_id, NOT NULL]
  - file_id: int(10) [PRIMARY KEY, FK -> client_files.file_id, NOT NULL]
  - linked_at: datetime [DEFAULT (getdate())]

--- payments ---
  - payment_id: int(10) [PRIMARY KEY, NOT NULL]
  - contract_id: int(10) [FK -> contracts.contract_id, NOT NULL]
  - client_id: int(10) [FK -> clients.client_id, NOT NULL]
  - received_date: nvarchar(50)
  - total_assets: float(53)
  - expected_fee: float(53)
  - actual_fee: float(53)
  - method: nvarchar(50)
  - notes: nvarchar(-1)
  - valid_from: datetime [DEFAULT (getdate())]
  - valid_to: datetime
  - applied_period_type: nvarchar(10)
  - applied_period: int(10)
  - applied_year: int(10)

--- quarterly_summaries ---
  - id: int(10) [PRIMARY KEY, NOT NULL]
  - client_id: int(10) [FK -> clients.client_id, NOT NULL]
  - year: int(10) [NOT NULL]
  - quarter: int(10) [NOT NULL]
  - total_payments: float(53)
  - total_assets: float(53)
  - payment_count: int(10)
  - avg_payment: float(53)
  - expected_total: float(53)
  - last_updated: nvarchar(50)

--- yearly_summaries ---
  - id: int(10) [PRIMARY KEY, NOT NULL]
  - client_id: int(10) [FK -> clients.client_id, NOT NULL]
  - year: int(10) [NOT NULL]
  - total_payments: float(53)
  - total_assets: float(53)
  - payment_count: int(10)
  - avg_payment: float(53)
  - yoy_growth: float(53)
  - last_updated: nvarchar(50)

=== INDEXES ===

- client_metrics: idx_client_metrics_lookup (NONCLUSTERED)
- contacts: idx_contacts_client_id (NONCLUSTERED)
- contacts: idx_contacts_type (NONCLUSTERED)
- contracts: idx_contracts_client_id (NONCLUSTERED)
- contracts: idx_contracts_provider (NONCLUSTERED)
- payments: idx_payments_client_id (NONCLUSTERED)
- payments: idx_payments_contract_id (NONCLUSTERED)
- payments: idx_payments_date (NONCLUSTERED)
- quarterly_summaries: idx_quarterly_lookup (NONCLUSTERED)
- yearly_summaries: idx_yearly_lookup (NONCLUSTERED)

=== TRIGGERS ===


--- TRIGGER: update_client_metrics_after_payment (on payments) ---
CREATE TRIGGER update_client_metrics_after_payment

ON payments

AFTER INSERT, UPDATE, DELETE

AS

BEGIN

    -- Update metrics for affected clients

    WITH affected_clients AS (

        SELECT client_id FROM inserted

        UNION

        SELECT client_id FROM deleted

    )

    UPDATE cm

    SET 

        last_payment_date = lp.received_date,

        last_payment_amount = lp.actual_fee,

        last_recorded_assets = lp.total_assets,

        total_ytd_payments = ytd.total,

        avg_quarterly_payment = qavg.avg_payment,

        last_updated = CONVERT(nvarchar(50), GETDATE(), 120)

    FROM client_metrics cm

    INNER JOIN affected_clients ac ON cm.client_id = ac.client_id

    OUTER APPLY (

        SELECT TOP 1 received_date, actual_fee, total_assets

        FROM payments 

        WHERE client_id = cm.client_id AND valid_to IS NULL

        ORDER BY received_date DESC

    ) lp

    OUTER APPLY (

        SELECT SUM(actual_fee) as total

        FROM payments 

        WHERE client_id = cm.client_id 

        AND applied_year = YEAR(GETDATE())

        AND valid_to IS NULL

    ) ytd

    OUTER APPLY (

        SELECT AVG(total_payments) as avg_payment

        FROM quarterly_summaries

        WHERE client_id = cm.client_id

    ) qavg;

END;

--- TRIGGER: update_quarterly_after_payment (on payments) ---
CREATE TRIGGER [dbo].[update_quarterly_after_payment]

ON [dbo].[payments]

AFTER INSERT

AS

BEGIN

    SET NOCOUNT ON;

    

    MERGE quarterly_summaries AS target

    USING (

        SELECT 

            i.client_id, 

            i.applied_year as year, 

            i.applied_period as quarter,

            SUM(p.actual_fee) as total_payments, 

            AVG(p.total_assets) as total_assets, 

            COUNT(*) as payment_count, 

            AVG(p.actual_fee) as avg_payment, 

            MAX(p.expected_fee) as expected_total

        FROM inserted i

        JOIN payments p ON p.client_id = i.client_id 

            AND p.applied_year = i.applied_year 

            AND p.applied_period = i.applied_period

            AND p.applied_period_type = 'quarterly'

        WHERE i.applied_period_type = 'quarterly'

        GROUP BY i.client_id, i.applied_year, i.applied_period

    ) AS source

    ON target.client_id = source.client_id 

        AND target.year = source.year 

        AND target.quarter = source.quarter

    WHEN MATCHED THEN

        UPDATE SET 

            total_payments = source.total_payments,

            total_assets = source.total_assets,

            payment_count = source.payment_count,

            avg_payment = source.avg_payment,

            expected_total = source.expected_total,

            last_updated = CONVERT(NVARCHAR(50), GETDATE(), 120)

    WHEN NOT MATCHED THEN

        INSERT (client_id, year, quarter, total_payments, total_assets, 

                payment_count, avg_payment, expected_total, last_updated)

        VALUES (source.client_id, source.year, source.quarter, source.total_payments, 

                source.total_assets, source.payment_count, source.avg_payment, 

                source.expected_total, CONVERT(NVARCHAR(50), GETDATE(), 120));

END;

--- TRIGGER: update_yearly_after_quarterly (on quarterly_summaries) ---
CREATE TRIGGER update_yearly_after_quarterly

ON quarterly_summaries

AFTER INSERT

AS

BEGIN

    SET NOCOUNT ON;

    

    MERGE yearly_summaries AS target

    USING (

        SELECT 

            i.client_id, 

            i.year, 

            SUM(q.total_payments) as total_payments, 

            AVG(q.total_assets) as total_assets, 

            SUM(q.payment_count) as payment_count, 

            AVG(q.avg_payment) as avg_payment

        FROM inserted i

        JOIN quarterly_summaries q ON q.client_id = i.client_id AND q.year = i.year

        GROUP BY i.client_id, i.year

    ) AS source

    ON target.client_id = source.client_id AND target.year = source.year

    WHEN MATCHED THEN

        UPDATE SET 

            total_payments = source.total_payments,

            total_assets = source.total_assets,

            payment_count = source.payment_count,

            avg_payment = source.avg_payment,

            last_updated = CONVERT(NVARCHAR(50), GETDATE(), 120)

    WHEN NOT MATCHED THEN

        INSERT (client_id, year, total_payments, total_assets, 

                payment_count, avg_payment, yoy_growth, last_updated)

        VALUES (source.client_id, source.year, source.total_payments, 

                source.total_assets, source.payment_count, source.avg_payment, 

                NULL, CONVERT(NVARCHAR(50), GETDATE(), 120));

END;


=== VIEWS ===


--- VIEW: client_payment_status ---
CREATE VIEW client_payment_status AS

SELECT

    c.client_id,

    c.display_name,

    ct.payment_schedule,

    ct.fee_type,

    ct.flat_rate,

    ct.percent_rate,

    cm.last_payment_date,

    cm.last_payment_amount,

    latest.applied_period,

    latest.applied_year,

    latest.applied_period_type,

    

    -- Current period calculation (one period back from today)

    CASE 

        WHEN ct.payment_schedule = 'monthly' THEN 

            CASE WHEN MONTH(GETDATE()) = 1 THEN 12 ELSE MONTH(GETDATE()) - 1 END

        WHEN ct.payment_schedule = 'quarterly' THEN 

            CASE WHEN DATEPART(QUARTER, GETDATE()) = 1 THEN 4 ELSE DATEPART(QUARTER, GETDATE()) - 1 END

    END AS current_period,

    

    CASE 

        WHEN MONTH(GETDATE()) = 1 AND ct.payment_schedule = 'monthly' THEN YEAR(GETDATE()) - 1

        WHEN DATEPART(QUARTER, GETDATE()) = 1 AND ct.payment_schedule = 'quarterly' THEN YEAR(GETDATE()) - 1

        ELSE YEAR(GETDATE())

    END AS current_year,

    

    cm.last_recorded_assets,

    

    CASE

        WHEN ct.fee_type = 'flat' THEN ct.flat_rate

        WHEN ct.fee_type = 'percentage' AND cm.last_recorded_assets IS NOT NULL THEN 

            ROUND(cm.last_recorded_assets * (ct.percent_rate / 100.0), 2)

        ELSE NULL

    END AS expected_fee,

    

    -- Simplified payment status

    CASE

        WHEN latest.applied_year IS NULL THEN 'Due'

        WHEN latest.applied_year < CASE 

            WHEN (MONTH(GETDATE()) = 1 AND ct.payment_schedule = 'monthly') OR 

                 (DATEPART(QUARTER, GETDATE()) = 1 AND ct.payment_schedule = 'quarterly') 

            THEN YEAR(GETDATE()) - 1

            ELSE YEAR(GETDATE()) 

        END THEN 'Due'

        WHEN latest.applied_year = CASE 

            WHEN (MONTH(GETDATE()) = 1 AND ct.payment_schedule = 'monthly') OR 

                 (DATEPART(QUARTER, GETDATE()) = 1 AND ct.payment_schedule = 'quarterly') 

            THEN YEAR(GETDATE()) - 1

            ELSE YEAR(GETDATE()) 

        END AND latest.applied_period < CASE

            WHEN ct.payment_schedule = 'monthly' THEN 

                CASE WHEN MONTH(GETDATE()) = 1 THEN 12 ELSE MONTH(GETDATE()) - 1 END

            WHEN ct.payment_schedule = 'quarterly' THEN 

                CASE WHEN DATEPART(QUARTER, GETDATE()) = 1 THEN 4 ELSE DATEPART(QUARTER, GETDATE()) - 1 END

        END THEN 'Due'

        ELSE 'Paid'

    END AS payment_status

FROM clients c

JOIN contracts ct ON c.client_id = ct.client_id AND ct.valid_to IS NULL

LEFT JOIN client_metrics cm ON c.client_id = cm.client_id

LEFT JOIN (

    SELECT * FROM (

        SELECT *, ROW_NUMBER() OVER (PARTITION BY client_id ORDER BY received_date DESC) as rn

        FROM payments WHERE valid_to IS NULL

    ) AS numbered WHERE rn = 1

) latest ON c.client_id = latest.client_id

WHERE c.valid_to IS NULL;

--- VIEW: payment_file_view ---
CREATE VIEW payment_file_view AS

SELECT 

    p.payment_id,

    p.client_id,

    p.contract_id,

    p.received_date,

    p.actual_fee,

    CASE WHEN cf.file_id IS NOT NULL THEN 1 ELSE 0 END AS has_file,

    cf.file_id,

    cf.file_name,

    cf.onedrive_path

FROM 

    payments p

LEFT JOIN 

    payment_files pf ON p.payment_id = pf.payment_id

LEFT JOIN 

    client_files cf ON pf.file_id = cf.file_id;
```

database\database.py
```py
import os
import pyodbc
import struct
import logging
from pathlib import Path
from contextlib import contextmanager
from typing import Optional, Generator, List, Any, Tuple
from azure.identity import DefaultAzureCredential
from dotenv import load_dotenv

# Configure logging
logger = logging.getLogger(__name__)


class DatabaseNotInitializedError(Exception):
    """Raised when attempting to use the database before it's initialized."""
    pass


def find_project_root() -> Path:
    """
    Find the project root directory by looking for marker files.
    
    Searches up the directory tree for common project root indicators.
    
    Returns:
        Path: The project root directory
    
    Raises:
        FileNotFoundError: If no project root markers are found
    """
    current_path = Path(__file__).resolve()
    
    # Look for these marker files that indicate project root
    markers = ['.env.local', 'package.json', '.git']
    
    for parent in current_path.parents:
        for marker in markers:
            if (parent / marker).exists():
                logger.debug(f"Found project root at {parent} (marker: {marker})")
                return parent
    
    # If no markers found, fall back to 3 levels up (original behavior)
    fallback = current_path.parent.parent.parent
    logger.warning(f"No project root markers found, using fallback: {fallback}")
    return fallback


# Load environment variables from the project root
try:
    env = os.getenv('TEAMSFX_ENV', 'local')
    env_file = f'.env.{env}' if env != 'local' else '.env.local'
    root_dir = find_project_root()
    env_path = root_dir / env_file
    
    if env_path.exists():
        load_dotenv(env_path)
        logger.info(f"Loaded environment from {env_path}")
    else:
        logger.warning(f"Environment file not found: {env_path}")
except Exception as e:
    logger.error(f"Error loading environment variables: {str(e)}")

class Database:
    """
    Database connection manager for Azure SQL Database using Azure AD authentication.
    
    This class handles connection management, authentication, and provides context
    managers for safe database operations with automatic cleanup.
    """
    
    # SQL Server specific constant for access token
    SQL_COPT_SS_ACCESS_TOKEN = 1256
    
    def __init__(self):
        """
        Initialize the Database instance with connection configuration.
        
        Loads connection parameters from environment variables and prepares
        the connection string for Azure SQL Database.
        """
        self.connection_string = self._get_connection_string()
        self._credential = None
        logger.info("Database instance initialized")
        
    def _get_connection_string(self) -> str:
        """
        Build the connection string from environment variables.
        
        Returns:
            str: Formatted connection string for Azure SQL Database
        
        Raises:
            ValueError: If required environment variables are missing
        """
        server = os.getenv("SQL_SERVER")
        database = os.getenv("SQL_DATABASE")
        
        if not server or not database:
            raise ValueError(
                "Missing required environment variables: SQL_SERVER and/or SQL_DATABASE"
            )
        
        connection_string = (
            f"Driver={{ODBC Driver 18 for SQL Server}};"
            f"Server=tcp:{server},1433;"
            f"Database={database};"
            f"Encrypt=yes;"
            f"TrustServerCertificate=no;"
            f"Connection Timeout=30"
        )
        
        # Check if SQL authentication is configured (for local development)
        sql_user = os.getenv("SQL_USER")
        sql_password = os.getenv("SQL_PASSWORD")
        
        if sql_user and sql_password:
            connection_string += f";UID={sql_user};PWD={sql_password}"
            logger.debug(f"Using SQL authentication for user: {sql_user}")
        
        logger.debug(f"Connection string prepared for server: {server}")
        return connection_string
    
    @property
    def credential(self) -> DefaultAzureCredential:
        """
        Get or create the Azure credential instance.
        
        Uses lazy initialization to create the credential only when needed.
        
        Returns:
            DefaultAzureCredential: Azure credential for authentication
        """
        if self._credential is None:
            self._credential = DefaultAzureCredential(
                exclude_interactive_browser_credential=False
            )
        return self._credential
    
    def _get_access_token(self) -> bytes:
        """
        Get an access token for Azure SQL Database authentication.
        
        Returns:
            bytes: Formatted access token for SQL Server connection
        
        Raises:
            Exception: If token acquisition fails
        """
        try:
            token = self.credential.get_token("https://database.windows.net/.default")
            token_bytes = token.token.encode("UTF-16-LE")
            token_struct = struct.pack(f'<I{len(token_bytes)}s', len(token_bytes), token_bytes)
            return token_struct
        except Exception as e:
            logger.error(f"Failed to acquire access token: {str(e)}")
            raise
    
    def get_connection(self) -> pyodbc.Connection:
        """
        Create a new database connection using Azure AD or SQL authentication.
        
        Returns:
            pyodbc.Connection: Active database connection
        
        Raises:
            pyodbc.Error: If connection fails
            Exception: If authentication fails
        """
        try:
            # Check if SQL authentication is configured
            if os.getenv("SQL_USER") and os.getenv("SQL_PASSWORD"):
                # Use SQL authentication (for local development)
                conn = pyodbc.connect(self.connection_string)
            else:
                # Use Azure AD authentication (for production)
                token_struct = self._get_access_token()
                
                conn = pyodbc.connect(
                    self.connection_string,
                    attrs_before={self.SQL_COPT_SS_ACCESS_TOKEN: token_struct}
                )
            
            logger.debug("Database connection established successfully")
            return conn
            
        except pyodbc.Error as e:
            logger.error(f"Database connection failed: {str(e)}")
            raise
        except Exception as e:
            logger.error(f"Unexpected error during connection: {str(e)}")
            raise
    
    @contextmanager
    def connection(self) -> Generator[pyodbc.Connection, None, None]:
        """
        Context manager for database connections with automatic cleanup.
        
        Ensures connections are properly closed even if exceptions occur.
        
        Yields:
            pyodbc.Connection: Active database connection
        
        Example:
            with db.connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT * FROM users")
        """
        conn = None
        try:
            conn = self.get_connection()
            yield conn
        except Exception as e:
            logger.error(f"Error during database operation: {str(e)}")
            raise
        finally:
            if conn:
                try:
                    conn.close()
                    logger.debug("Database connection closed")
                except Exception as e:
                    logger.warning(f"Error closing connection: {str(e)}")
    
    @contextmanager
    def cursor(self, commit: bool = True) -> Generator[pyodbc.Cursor, None, None]:
        """
        Context manager for database cursors with automatic transaction handling.
        
        Args:
            commit: Whether to commit the transaction on success (default: True)
        
        Yields:
            pyodbc.Cursor: Active database cursor
        
        Example:
            with db.cursor() as cursor:
                cursor.execute("INSERT INTO users (name) VALUES (?)", ["John"])
        """
        with self.connection() as conn:
            cursor = None
            try:
                cursor = conn.cursor()
                yield cursor
                if commit:
                    conn.commit()
                    logger.debug("Transaction committed")
            except Exception as e:
                conn.rollback()
                logger.error(f"Transaction rolled back due to error: {str(e)}")
                raise
            finally:
                if cursor:
                    try:
                        cursor.close()
                    except Exception as e:
                        logger.warning(f"Error closing cursor: {str(e)}")
    
    def execute_query(self, query: str, params: Optional[Tuple[Any, ...]] = None, 
                     commit: bool = False) -> List[Any]:
        """
        Execute a query and return all results.
        
        Args:
            query: SQL query to execute
            params: Query parameters (optional)
            commit: Whether to commit the transaction (default: False)
        
        Returns:
            list: Query results as list of rows
        
        Raises:
            pyodbc.Error: If query execution fails
        """
        with self.cursor(commit=commit) as cursor:
            if params:
                cursor.execute(query, params)
            else:
                cursor.execute(query)
            
            if cursor.description:  # SELECT query
                results = cursor.fetchall()
                logger.debug(f"Query returned {len(results)} rows")
                return results
            else:  # INSERT/UPDATE/DELETE
                logger.debug(f"Query affected {cursor.rowcount} rows")
                return []

# Global database instance
_db: Optional[Database] = None

try:
    _db = Database()
    logger.info("Global database instance created successfully")
except Exception as e:
    logger.error(f"Failed to initialize database: {str(e)}")
    _db = None


def get_db() -> Database:
    """
    Get the global database instance.
    
    Returns:
        Database: The initialized database instance
    
    Raises:
        DatabaseNotInitializedError: If the database failed to initialize
    """
    if _db is None:
        raise DatabaseNotInitializedError(
            "Database not initialized. Check your environment variables and Azure credentials. "
            "Required: SQL_SERVER and SQL_DATABASE environment variables."
        )
    return _db


# For backward compatibility
db = _db
```

database\models.py
```py
"""
Pydantic models for the 401(k) Payment Tracking System database schema.
"""
from datetime import datetime
from typing import Optional, Literal
from pydantic import BaseModel, Field, field_validator, ConfigDict
from decimal import Decimal


# Custom validators
def validate_percentage(v: Optional[float]) -> Optional[float]:
    """Validate percentage is between 0 and 1."""
    if v is not None and not 0 <= v <= 1:
        raise ValueError('Percentage must be between 0 and 1 (e.g., 0.0025 for 0.25%)')
    return v


def validate_positive_amount(v: Optional[float]) -> Optional[float]:
    """Validate amount is positive."""
    if v is not None and v < 0:
        raise ValueError('Amount must be positive')
    return v


# Base models with common fields
class TimestampedModel(BaseModel):
    """Base model with temporal validity tracking."""
    valid_from: datetime = Field(default_factory=datetime.now, description="When this record became valid")
    valid_to: Optional[datetime] = Field(default=None, description="When this record became invalid (NULL for active records)")


# Client models
class ClientBase(BaseModel):
    """Base client information."""
    display_name: str = Field(..., max_length=255, description="Short name for UI display (e.g., 'AirSea America')")
    full_name: Optional[str] = Field(None, max_length=255, description="Legal plan name")
    ima_signed_date: Optional[str] = Field(None, max_length=50, description="Investment Management Agreement date")
    onedrive_folder_path: Optional[str] = Field(None, max_length=500, description="Path to client's document folder")
    
    @field_validator('display_name')
    @classmethod
    def validate_not_empty(cls, v):
        if not v or not v.strip():
            raise ValueError('display_name cannot be empty')
        return v


class ClientCreate(ClientBase):
    """Model for creating a new client."""
    pass


class ClientUpdate(BaseModel):
    """Model for updating an existing client."""
    display_name: Optional[str] = Field(None, max_length=255)
    full_name: Optional[str] = Field(None, max_length=255)
    ima_signed_date: Optional[str] = Field(None, max_length=50)
    onedrive_folder_path: Optional[str] = Field(None, max_length=500)


class Client(ClientBase, TimestampedModel):
    """Complete client model with all fields."""
    model_config = ConfigDict(from_attributes=True)
    
    client_id: int = Field(..., description="Primary key")


# Contract models
class ContractBase(BaseModel):
    """Base contract information."""
    client_id: int = Field(..., description="Foreign key to clients table")
    contract_number: Optional[str] = Field(None, max_length=100, description="Contract identifier")
    provider_name: Optional[str] = Field(None, max_length=255, description="401(k) provider (e.g., 'John Hancock', 'Voya')")
    contract_start_date: Optional[str] = Field(None, max_length=50, description="When the contract began")
    fee_type: Optional[Literal['percentage', 'flat']] = Field(None, description="Type of fee structure")
    percent_rate: Optional[float] = Field(None, description="Rate for percentage-based fees (e.g., 0.0025 for 0.25%)")
    flat_rate: Optional[float] = Field(None, description="Dollar amount for flat fees")
    payment_schedule: Optional[Literal['monthly', 'quarterly']] = Field(None, description="Payment frequency")
    num_people: Optional[int] = Field(None, description="Participant count in the plan")
    notes: Optional[str] = Field(None, description="Additional contract notes")
    
    @field_validator('percent_rate')
    @classmethod
    def validate_percent_rate(cls, v: Optional[float]) -> Optional[float]:
        return validate_percentage(v)
    
    @field_validator('flat_rate')
    @classmethod
    def validate_flat_rate(cls, v: Optional[float]) -> Optional[float]:
        return validate_positive_amount(v)
    
    @field_validator('fee_type', 'percent_rate', 'flat_rate')
    @classmethod
    def validate_fee_consistency(cls, v, info):
        """Ensure fee structure is consistent."""
        data = info.data
        if 'fee_type' in data:
            if data['fee_type'] == 'percentage' and 'percent_rate' in data and data['percent_rate'] is None:
                raise ValueError('percent_rate is required for percentage fee type')
            elif data['fee_type'] == 'flat' and 'flat_rate' in data and data['flat_rate'] is None:
                raise ValueError('flat_rate is required for flat fee type')
        return v


class ContractCreate(ContractBase):
    """Model for creating a new contract."""
    pass


class ContractUpdate(BaseModel):
    """Model for updating an existing contract."""
    contract_number: Optional[str] = Field(None, max_length=100)
    provider_name: Optional[str] = Field(None, max_length=255)
    contract_start_date: Optional[str] = Field(None, max_length=50)
    fee_type: Optional[Literal['percentage', 'flat']] = None
    percent_rate: Optional[float] = None
    flat_rate: Optional[float] = None
    payment_schedule: Optional[Literal['monthly', 'quarterly']] = None
    num_people: Optional[int] = None
    notes: Optional[str] = None


class Contract(ContractBase, TimestampedModel):
    """Complete contract model with all fields."""
    model_config = ConfigDict(from_attributes=True)
    
    contract_id: int = Field(..., description="Primary key")


# Payment models
class PaymentBase(BaseModel):
    """Base payment information."""
    contract_id: int = Field(..., description="Foreign key to contracts table")
    client_id: int = Field(..., description="Foreign key to clients table")
    received_date: Optional[str] = Field(None, max_length=50, description="When payment was received")
    total_assets: Optional[float] = Field(None, description="Plan assets for the period")
    expected_fee: Optional[float] = Field(None, description="Calculated expected amount")
    actual_fee: Optional[float] = Field(None, description="Amount actually received")
    method: Optional[str] = Field(None, max_length=50, description="Payment method (e.g., 'Auto - ACH', 'Auto - Check')")
    notes: Optional[str] = Field(None, description="Payment notes")
    applied_period_type: Optional[Literal['monthly', 'quarterly']] = Field(None, max_length=10, description="Period type this payment applies to")
    applied_period: Optional[int] = Field(None, ge=1, le=12, description="Period number (1-12 for months, 1-4 for quarters)")
    applied_year: Optional[int] = Field(None, ge=2000, le=2100, description="Year the payment applies to")
    
    @field_validator('total_assets', 'expected_fee', 'actual_fee')
    @classmethod
    def validate_amounts(cls, v: Optional[float]) -> Optional[float]:
        return validate_positive_amount(v)
    
    @field_validator('applied_period')
    @classmethod
    def validate_period_range(cls, v: Optional[int], info) -> Optional[int]:
        """Ensure period is within valid range based on period type."""
        if v is not None and 'applied_period_type' in info.data:
            period_type = info.data['applied_period_type']
            if period_type == 'quarterly' and v > 4:
                raise ValueError('Quarterly period must be between 1 and 4')
        return v


class PaymentCreate(PaymentBase):
    """Model for creating a new payment."""
    pass


class PaymentUpdate(BaseModel):
    """Model for updating an existing payment."""
    received_date: Optional[str] = Field(None, max_length=50)
    total_assets: Optional[float] = None
    expected_fee: Optional[float] = None
    actual_fee: Optional[float] = None
    method: Optional[str] = Field(None, max_length=50)
    notes: Optional[str] = None
    applied_period_type: Optional[Literal['monthly', 'quarterly']] = None
    applied_period: Optional[int] = Field(None, ge=1, le=12)
    applied_year: Optional[int] = Field(None, ge=2000, le=2100)


class Payment(PaymentBase, TimestampedModel):
    """Complete payment model with all fields."""
    model_config = ConfigDict(from_attributes=True)
    
    payment_id: int = Field(..., description="Primary key")


# Contact models
class ContactBase(BaseModel):
    """Base contact information."""
    client_id: int = Field(..., description="Foreign key to clients table")
    contact_type: str = Field(..., max_length=50, description="Type of contact (e.g., 'primary', 'provider')")
    contact_name: Optional[str] = Field(None, max_length=255, description="Name of the contact")
    phone: Optional[str] = Field(None, max_length=50, description="Phone number")
    email: Optional[str] = Field(None, max_length=255, description="Email address")
    fax: Optional[str] = Field(None, max_length=50, description="Fax number")
    physical_address: Optional[str] = Field(None, max_length=500, description="Physical/street address")
    mailing_address: Optional[str] = Field(None, max_length=500, description="Mailing address")
    
    @field_validator('email')
    @classmethod
    def validate_email(cls, v: Optional[str]) -> Optional[str]:
        """Basic email validation."""
        if v and '@' not in v:
            raise ValueError('Invalid email format')
        return v


class ContactCreate(ContactBase):
    """Model for creating a new contact."""
    pass


class ContactUpdate(BaseModel):
    """Model for updating an existing contact."""
    contact_type: Optional[str] = Field(None, max_length=50)
    contact_name: Optional[str] = Field(None, max_length=255)
    phone: Optional[str] = Field(None, max_length=50)
    email: Optional[str] = Field(None, max_length=255)
    fax: Optional[str] = Field(None, max_length=50)
    physical_address: Optional[str] = Field(None, max_length=500)
    mailing_address: Optional[str] = Field(None, max_length=500)


class Contact(ContactBase, TimestampedModel):
    """Complete contact model with all fields."""
    model_config = ConfigDict(from_attributes=True)
    
    contact_id: int = Field(..., description="Primary key")


# File models
class ClientFileBase(BaseModel):
    """Base client file information."""
    client_id: int = Field(..., description="Foreign key to clients table")
    file_name: str = Field(..., max_length=255, description="Name of the file")
    onedrive_path: str = Field(..., max_length=500, description="Path to file in OneDrive")


class ClientFileCreate(ClientFileBase):
    """Model for creating a new client file."""
    pass


class ClientFile(ClientFileBase):
    """Complete client file model with all fields."""
    model_config = ConfigDict(from_attributes=True)
    
    file_id: int = Field(..., description="Primary key")
    uploaded_at: datetime = Field(default_factory=datetime.now, description="When the file was uploaded")


# Payment file link models
class PaymentFileLink(BaseModel):
    """Model for linking payments to files."""
    model_config = ConfigDict(from_attributes=True)
    
    payment_id: int = Field(..., description="Foreign key to payments table")
    file_id: int = Field(..., description="Foreign key to client_files table")
    linked_at: datetime = Field(default_factory=datetime.now, description="When the link was created")


# Metrics models
class ClientMetrics(BaseModel):
    """Cached calculations for dashboard performance."""
    model_config = ConfigDict(from_attributes=True)
    
    id: int = Field(..., description="Primary key")
    client_id: int = Field(..., description="Foreign key to clients table")
    last_payment_date: Optional[str] = Field(None, max_length=50, description="Date of most recent payment")
    last_payment_amount: Optional[float] = Field(None, description="Amount of most recent payment")
    last_payment_quarter: Optional[int] = Field(None, ge=1, le=4, description="Quarter of most recent payment")
    last_payment_year: Optional[int] = Field(None, ge=2000, le=2100, description="Year of most recent payment")
    total_ytd_payments: Optional[float] = Field(None, description="Total payments year-to-date")
    avg_quarterly_payment: Optional[float] = Field(None, description="Average quarterly payment amount")
    last_recorded_assets: Optional[float] = Field(None, description="Most recently recorded asset value")
    last_updated: Optional[str] = Field(None, max_length=50, description="When metrics were last updated")
    next_payment_due: Optional[str] = Field(None, max_length=50, description="Next expected payment date")


# Summary models
class QuarterlySummary(BaseModel):
    """Pre-aggregated quarterly data for reporting."""
    model_config = ConfigDict(from_attributes=True)
    
    id: int = Field(..., description="Primary key")
    client_id: int = Field(..., description="Foreign key to clients table")
    year: int = Field(..., ge=2000, le=2100, description="Year of the summary")
    quarter: int = Field(..., ge=1, le=4, description="Quarter number (1-4)")
    total_payments: Optional[float] = Field(None, description="Total payments for the quarter")
    total_assets: Optional[float] = Field(None, description="Total assets for the quarter")
    payment_count: Optional[int] = Field(None, ge=0, description="Number of payments in the quarter")
    avg_payment: Optional[float] = Field(None, description="Average payment amount")
    expected_total: Optional[float] = Field(None, description="Expected total for the quarter")
    last_updated: Optional[str] = Field(None, max_length=50, description="When summary was last updated")


class YearlySummary(BaseModel):
    """Pre-aggregated yearly data for reporting."""
    model_config = ConfigDict(from_attributes=True)
    
    id: int = Field(..., description="Primary key")
    client_id: int = Field(..., description="Foreign key to clients table")
    year: int = Field(..., ge=2000, le=2100, description="Year of the summary")
    total_payments: Optional[float] = Field(None, description="Total payments for the year")
    total_assets: Optional[float] = Field(None, description="Total assets for the year")
    payment_count: Optional[int] = Field(None, ge=0, description="Number of payments in the year")
    avg_payment: Optional[float] = Field(None, description="Average payment amount")
    yoy_growth: Optional[float] = Field(None, description="Year-over-year growth percentage")
    last_updated: Optional[str] = Field(None, max_length=50, description="When summary was last updated")


# Response models for API endpoints
class ClientWithContract(Client):
    """Client with associated contract information."""
    contract: Optional[Contract] = None


class PaymentWithFiles(Payment):
    """Payment with associated file information."""
    files: list[ClientFile] = Field(default_factory=list)


class ClientPaymentStatus(BaseModel):
    """Current payment status for a client."""
    model_config = ConfigDict(from_attributes=True)
    
    client: Client
    contract: Optional[Contract]
    last_payment: Optional[Payment]
    status: Literal['Due', 'Paid']
    missing_periods: list[dict] = Field(default_factory=list, description="List of missing payment periods")
    next_due_period: Optional[dict] = None
```

host.json
```json
{
  "version": "2.0",
  "logging": {
    "applicationInsights": {
      "samplingSettings": {
        "isEnabled": true,
        "excludedTypes": "Request"
      }
    }
  },
  "extensionBundle": {
    "id": "Microsoft.Azure.Functions.ExtensionBundle",
    "version": "[4.*, 5.0.0)"
  },
  "extensions": {
    "http": {
      "routePrefix": "api"
    }
  },
  "functionTimeout": "00:05:00",
  "environment": {
    "PYTHON_ISOLATE_WORKER_DEPENDENCIES": "1"
  }
}
```

local.settings.json
```json
{
  "IsEncrypted": false,
  "Values": {
    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
    "FUNCTIONS_WORKER_RUNTIME": "python",
    "SQL_SERVER": "hohimerpro-db-server.database.windows.net",
    "SQL_DATABASE": "HohimerPro-401k",
    "SQL_USER": "your-sql-username",
    "SQL_PASSWORD": "your-sql-password",
    "TEAMSFX_ENV": "local"
  },
  "Host": {
    "CORS": "*"
  }
}
```

payments\__init__.py
```py
# api/payments/__init__.py

"""
Azure Function for managing payment endpoints.
Handles payment CRUD operations using the new simplified schema.
"""
import azure.functions as func
import json
import sys
import os
from datetime import datetime
from typing import Dict, Any, Optional

# Add backend to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from database.database import get_db
from database.models import Payment, PaymentCreate, PaymentUpdate


async def main(req: func.HttpRequest) -> func.HttpResponse:
    """
    Handle payment-related HTTP requests.
    
    Routes:
    - GET /api/payments?client_id={id} - List payments for a client
    - GET /api/payments/{id} - Get specific payment
    - POST /api/payments - Create new payment
    - PUT /api/payments/{id} - Update payment
    - DELETE /api/payments/{id} - Soft delete payment
    """
    
    payment_id = req.route_params.get('id')
    
    try:
        db = get_db()
        
        # GET payments with filters
        if req.method == "GET" and not payment_id:
            client_id = req.params.get('client_id')
            year = req.params.get('year')
            page = int(req.params.get('page', 1))
            limit = int(req.params.get('limit', 50))
            offset = (page - 1) * limit
            
            if not client_id:
                return func.HttpResponse(
                    json.dumps({"error": "client_id parameter required"}),
                    status_code=400,
                    mimetype="application/json"
                )
            
            with db.cursor(commit=False) as cursor:
                query = """
                    SELECT p.payment_id, p.contract_id, p.client_id, p.received_date,
                           p.total_assets, p.expected_fee, p.actual_fee, p.method, p.notes,
                           p.applied_period_type, p.applied_period, p.applied_year,
                           p.valid_from, p.valid_to,
                           c.display_name as client_name, 
                           co.provider_name, co.fee_type, co.percent_rate, 
                           co.flat_rate, co.payment_schedule,
                           CASE WHEN pf.payment_id IS NOT NULL THEN 1 ELSE 0 END as has_files
                    FROM payments p
                    JOIN clients c ON p.client_id = c.client_id
                    LEFT JOIN contracts co ON p.contract_id = co.contract_id
                    LEFT JOIN payment_files pf ON p.payment_id = pf.payment_id
                    WHERE p.client_id = ? AND p.valid_to IS NULL
                """
                
                params = [int(client_id)]
                
                if year:
                    query += " AND p.applied_year = ?"
                    params.append(int(year))
                
                # Group by all non-aggregate columns to handle multiple files
                query += """
                    GROUP BY p.payment_id, p.contract_id, p.client_id, p.received_date,
                             p.total_assets, p.expected_fee, p.actual_fee, p.method, p.notes,
                             p.applied_period_type, p.applied_period, p.applied_year,
                             p.valid_from, p.valid_to, c.display_name, 
                             co.provider_name, co.fee_type, co.percent_rate, 
                             co.flat_rate, co.payment_schedule
                    ORDER BY p.received_date DESC
                    OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
                """
                params.extend([offset, limit])
                
                cursor.execute(query, params)
                columns = [column[0] for column in cursor.description]
                rows = cursor.fetchall()
            
            # Convert to list of dictionaries
            payments = []
            for row in rows:
                payment_dict = dict(zip(columns, row))
                
                # Calculate expected fee if not stored
                if payment_dict['expected_fee'] is None:
                    if payment_dict['fee_type'] == 'percentage' and payment_dict['percent_rate'] and payment_dict['total_assets']:
                        payment_dict['expected_fee'] = payment_dict['total_assets'] * payment_dict['percent_rate']
                    elif payment_dict['fee_type'] == 'flat' and payment_dict['flat_rate']:
                        payment_dict['expected_fee'] = payment_dict['flat_rate']
                
                payments.append(payment_dict)
            
            return func.HttpResponse(
                json.dumps(payments, default=str),
                mimetype="application/json"
            )
        
        # GET single payment
        elif req.method == "GET" and payment_id:
            with db.cursor(commit=False) as cursor:
                query = """
                    SELECT p.payment_id, p.contract_id, p.client_id, p.received_date,
                           p.total_assets, p.expected_fee, p.actual_fee, p.method, p.notes,
                           p.applied_period_type, p.applied_period, p.applied_year,
                           p.valid_from, p.valid_to,
                           c.display_name as client_name, 
                           co.provider_name, co.fee_type, co.percent_rate, 
                           co.flat_rate, co.payment_schedule,
                           CASE WHEN COUNT(pf.file_id) > 0 THEN 1 ELSE 0 END as has_files
                    FROM payments p
                    JOIN clients c ON p.client_id = c.client_id
                    LEFT JOIN contracts co ON p.contract_id = co.contract_id
                    LEFT JOIN payment_files pf ON p.payment_id = pf.payment_id
                    WHERE p.payment_id = ? AND p.valid_to IS NULL
                    GROUP BY p.payment_id, p.contract_id, p.client_id, p.received_date,
                             p.total_assets, p.expected_fee, p.actual_fee, p.method, p.notes,
                             p.applied_period_type, p.applied_period, p.applied_year,
                             p.valid_from, p.valid_to, c.display_name, 
                             co.provider_name, co.fee_type, co.percent_rate, 
                             co.flat_rate, co.payment_schedule
                """
                cursor.execute(query, [int(payment_id)])
                columns = [column[0] for column in cursor.description]
                row = cursor.fetchone()
            
            if not row:
                return func.HttpResponse(
                    json.dumps({"error": "Payment not found"}),
                    status_code=404,
                    mimetype="application/json"
                )
            
            payment_dict = dict(zip(columns, row))
            
            # Calculate expected fee if not stored
            if payment_dict['expected_fee'] is None:
                if payment_dict['fee_type'] == 'percentage' and payment_dict['percent_rate'] and payment_dict['total_assets']:
                    payment_dict['expected_fee'] = payment_dict['total_assets'] * payment_dict['percent_rate']
                elif payment_dict['fee_type'] == 'flat' and payment_dict['flat_rate']:
                    payment_dict['expected_fee'] = payment_dict['flat_rate']
            
            return func.HttpResponse(
                json.dumps(payment_dict, default=str),
                mimetype="application/json"
            )
        
        # POST - Create new payment
        elif req.method == "POST":
            try:
                req_body = req.get_json()
                payment_create = PaymentCreate(**req_body)
            except (ValueError, TypeError) as e:
                return func.HttpResponse(
                    json.dumps({"error": f"Invalid request body: {str(e)}"}),
                    status_code=400,
                    mimetype="application/json"
                )
            
            with db.cursor() as cursor:
                # Insert payment using new schema
                cursor.execute("""
                    INSERT INTO payments (
                        contract_id, client_id, received_date, total_assets,
                        expected_fee, actual_fee, method, notes,
                        applied_period_type, applied_period, applied_year
                    )
                    OUTPUT INSERTED.payment_id
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    payment_create.contract_id,
                    payment_create.client_id,
                    payment_create.received_date,
                    payment_create.total_assets,
                    payment_create.expected_fee,
                    payment_create.actual_fee,
                    payment_create.method,
                    payment_create.notes,
                    payment_create.applied_period_type,
                    payment_create.applied_period,
                    payment_create.applied_year
                ))
                new_id = cursor.fetchone()[0]
                
                # Note: Triggers will handle updating client_metrics and summaries automatically
            
            return func.HttpResponse(
                json.dumps({"payment_id": new_id, **payment_create.model_dump()}, default=str),
                mimetype="application/json",
                status_code=201
            )
        
        # PUT - Update payment
        elif req.method == "PUT" and payment_id:
            try:
                req_body = req.get_json()
                payment_update = PaymentUpdate(**req_body)
            except (ValueError, TypeError) as e:
                return func.HttpResponse(
                    json.dumps({"error": f"Invalid request body: {str(e)}"}),
                    status_code=400,
                    mimetype="application/json"
                )
            
            # Build dynamic update query
            update_fields = []
            params = []
            
            update_data = payment_update.model_dump(exclude_unset=True)
            if not update_data:
                return func.HttpResponse(
                    json.dumps({"error": "No fields to update"}),
                    status_code=400,
                    mimetype="application/json"
                )
            
            for field, value in update_data.items():
                update_fields.append(f"{field} = ?")
                params.append(value)
            
            params.append(int(payment_id))
            
            with db.cursor() as cursor:
                query = f"""
                    UPDATE payments 
                    SET {', '.join(update_fields)}
                    WHERE payment_id = ? AND valid_to IS NULL
                """
                cursor.execute(query, params)
                
                if cursor.rowcount == 0:
                    return func.HttpResponse(
                        json.dumps({"error": "Payment not found"}),
                        status_code=404,
                        mimetype="application/json"
                    )
                
                # Note: Triggers will handle updating summaries automatically
            
            return func.HttpResponse(
                json.dumps({"message": "Payment updated successfully"}),
                mimetype="application/json"
            )
        
        # DELETE - Soft delete payment
        elif req.method == "DELETE" and payment_id:
            with db.cursor() as cursor:
                cursor.execute("""
                    UPDATE payments 
                    SET valid_to = GETDATE()
                    WHERE payment_id = ? AND valid_to IS NULL
                """, [int(payment_id)])
                
                if cursor.rowcount == 0:
                    return func.HttpResponse(
                        json.dumps({"error": "Payment not found"}),
                        status_code=404,
                        mimetype="application/json"
                    )
                
                # Note: Triggers will handle updating summaries automatically
            
            return func.HttpResponse(status_code=204)
        
        else:
            return func.HttpResponse(
                json.dumps({"error": "Method not allowed"}),
                status_code=405,
                mimetype="application/json"
            )
            
    except Exception as e:
        return func.HttpResponse(
            json.dumps({"error": str(e)}),
            status_code=500,
            mimetype="application/json"
        )
```

payments\function.json
```json
{
  "scriptFile": "__init__.py",
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get", "post", "put", "delete"],
      "route": "payments/{id?}"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "$return"
    }
  ]
}
```

periods\__init__.py
```py
"""
Azure Function for getting available payment periods.
Used by payment forms to show which periods can be selected.
"""
import azure.functions as func
import json
import sys
import os
from datetime import datetime

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
from database.database import get_db

async def main(req: func.HttpRequest) -> func.HttpResponse:
    """
    Get available periods for payment entry.
    Route: GET /api/periods?client_id={id}&contract_id={id}
    
    Returns list of periods that haven't been paid yet.
    """
    client_id = req.params.get('client_id')
    contract_id = req.params.get('contract_id')
    
    if not client_id or not contract_id:
        return func.HttpResponse(
            json.dumps({"error": "client_id and contract_id required"}),
            status_code=400,
            mimetype="application/json"
        )
    
    try:
        db = get_db()
        
        with db.cursor(commit=False) as cursor:
            # Get payment schedule from contract
            cursor.execute("""
                SELECT payment_schedule
                FROM contracts
                WHERE contract_id = ? AND client_id = ? AND valid_to IS NULL
            """, [int(contract_id), int(client_id)])
            
            row = cursor.fetchone()
            if not row:
                return func.HttpResponse(
                    json.dumps({"error": "Contract not found"}),
                    status_code=404,
                    mimetype="application/json"
                )
            
            payment_schedule = row[0]
            is_monthly = payment_schedule.lower() == 'monthly'
            
            # Get all paid periods
            cursor.execute("""
                SELECT DISTINCT applied_period, applied_year
                FROM payments
                WHERE client_id = ? 
                  AND valid_to IS NULL
                  AND applied_period_type = ?
                ORDER BY applied_year DESC, applied_period DESC
            """, [int(client_id), payment_schedule.lower()])
            
            paid_periods = set()
            for row in cursor.fetchall():
                paid_periods.add((row[0], row[1]))
            
            # Get the earliest payment to determine starting point
            cursor.execute("""
                SELECT MIN(applied_year) as first_year,
                       MIN(CASE WHEN applied_year = (SELECT MIN(applied_year) FROM payments WHERE client_id = ?)
                                THEN applied_period END) as first_period
                FROM payments
                WHERE client_id = ? AND valid_to IS NULL
            """, [int(client_id), int(client_id)])
            
            row = cursor.fetchone()
            if row and row[0]:
                start_year = row[0]
                start_period = row[1] if row[1] else 1
            else:
                # No payments yet, start from beginning of current year
                start_year = datetime.now().year
                start_period = 1
            
            # Calculate current collection period (one back for arrears)
            current_date = datetime.now()
            
            if is_monthly:
                if current_date.month == 1:
                    current_period = 12
                    current_year = current_date.year - 1
                else:
                    current_period = current_date.month - 1
                    current_year = current_date.year
                max_period = 12
                period_names = [
                    'January', 'February', 'March', 'April', 'May', 'June',
                    'July', 'August', 'September', 'October', 'November', 'December'
                ]
            else:  # Quarterly
                current_quarter = (current_date.month - 1) // 3 + 1
                if current_quarter == 1:
                    current_period = 4
                    current_year = current_date.year - 1
                else:
                    current_period = current_quarter - 1
                    current_year = current_date.year
                max_period = 4
                period_names = ['Q1', 'Q2', 'Q3', 'Q4']
            
            # Generate available periods
            available_periods = []
            year = start_year
            period = start_period
            
            # Generate periods up to current collection period
            while year < current_year or (year == current_year and period <= current_period):
                if (period, year) not in paid_periods:
                    period_label = f"{period_names[period-1]} {year}"
                    available_periods.append({
                        'value': f"{period}-{year}",
                        'label': period_label,
                        'period': period,
                        'year': year,
                        'period_type': payment_schedule.lower()
                    })
                
                # Move to next period
                period += 1
                if period > max_period:
                    period = 1
                    year += 1
                
                # Safety check to prevent infinite loop
                if year > current_year + 1:
                    break
            
            # Reverse to show most recent first
            available_periods.reverse()
        
        return func.HttpResponse(
            json.dumps({
                'periods': available_periods,
                'payment_schedule': payment_schedule
            }, default=str),
            mimetype="application/json"
        )
        
    except Exception as e:
        return func.HttpResponse(
            json.dumps({"error": str(e)}),
            status_code=500,
            mimetype="application/json"
        )
```

periods\function.json
```json
{
  "scriptFile": "__init__.py",
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get"],
      "route": "periods"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "$return"
    }
  ]
}
```

requirements.txt
```txt
azure-functions
pyodbc
pydantic
azure-identity
python-dotenv
```

test-function\__init__.py
```py
import azure.functions as func
import logging

def main(req: func.HttpRequest) -> func.HttpResponse:
    logging.info('Python HTTP trigger function processed a request.')
    return func.HttpResponse("Test function works!", status_code=200)
```