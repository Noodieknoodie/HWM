# THESE DOCS ARE FOR FASTAPI 0.115.6

"FastAPI Additional Responses: Use responses parameter in path operation decorators for additional OpenAPI responses. responses={status_code: {\"model\": Model, \"description\": \"...\", \"content\": {...}}}. model key defines response schema using Pydantic model. Example: responses={404: {\"model\": Message}}. Define additional media types in responses. Combine response_model, status_code, and responses. Reuse responses with dict unpacking. JSONResponse allows returning custom HTTP status codes in FastAPI. Example: upsert_item(item_id str, name Optional[str], size Optional[int]) returns JSONResponse with status_code (e.g., status.HTTP_201_CREATED). FixedContentQueryChecker: __init__(fixed_content: str), __call__(q: str = \"\") -> bool. Checks if a query parameter contains fixed content. read_query_check(fixed_content_included: bool) -> dict. Uses FixedContentQueryChecker to check a query. FastAPI Async Tests: Use pytest.mark.anyio to mark tests as async. Use AsyncClient from httpx instead of TestClient for async tests. AsyncClient(transport=ASGITransport(app=app), base_url=\"http://test\"). Example: async with AsyncClient(...) as ac: response = await ac.get(\"/\"). AsyncClient does not trigger lifespan events. Behind a Proxy: Use root_path for proxy servers with path prefix. FastAPI(root_path=\"/api/v1\"). Command line option: --root-path /api/v1. Get current root_path: request.scope.get(\"root_path\"). Example: from fastapi import FastAPI, Request; app = FastAPI(); @app.get(\"/app\") def read_main(request: Request): return {\"message\": \"Hello World\", \"root_path\": request.scope.get(\"root_path\")}. Additional servers: servers=[{\"url\": \"...\", \"description\": \"...\"}], root_path=\"/api/v1\". Disable automatic server from root_path: root_path_in_servers=False. FastAPI internally uses root_path when mounting sub-applications. Custom Responses: Override default JSONResponse. Use `response_class` or return Response directly. `response_class` documents OpenAPI. Responses: `Response(content, status_code, headers, media_type)`, `HTMLResponse(content)`, `PlainTextResponse(content)`, `JSONResponse(content)`, `ORJSONResponse(content)`, `UJSONResponse(content)`, `RedirectResponse(url, status_code)`, `StreamingResponse(iterator, media_type)`, `FileResponse(path, filename, media_type, headers)`. `FastAPI(default_response_class=Response)` sets default. Using Dataclasses. FastAPI supports dataclasses for requests/responses. Example: @dataclass class Item: name: str; @app.post(\"/items/\") async def create_item(item: Item): return item. Dataclasses in response_model: use dataclasses in response_model. Nested Data Structures: combine dataclasses with type annotations. Use pydantic.dataclasses for API documentation errors. FastAPI Lifespan Events: Define startup/shutdown logic with lifespan parameter in FastAPI app. lifespan(app: FastAPI) - async context manager function with yield. Executes code before yield on startup and after yield on shutdown. Alternative: @app.on_event(\"startup\") async def startup_event(): and @app.on_event(\"shutdown\") def shutdown_event():. Lifespan recommended. Events for main app only. FastAPI OpenAPI spec enables client code generation. Tools: OpenAPI Generator, openapi-ts. Define models (e.g., Item BaseModel, ResponseMessage BaseModel) and path operations (create_item, get_items). Custom operation IDs for cleaner client method names using generate_unique_id_function. Advanced User Guide: additional FastAPI features beyond tutorial. Complements main tutorial. External courses available. ASGI Middlewares: Classes receiving an ASGI app as the first argument. Use app.add_middleware(MiddlewareClass, **kwargs). HTTPSRedirectMiddleware: Redirects http/ws requests to https/wss. TrustedHostMiddleware: Validates Host header. Args: allowed_hosts (list of str). GZipMiddleware: Handles GZip responses. Args: minimum_size (int, default 500), compresslevel (int, default 9, 1-9 range). OpenAPI Callbacks: Document external API requirements for callback requests. APIRouter: Create router for callbacks. @invoices_callback_router.post(\"{$callback_url}/invoices/{$request.body.id}\", response_model=InvoiceEventReceived) def invoice_notification(body: InvoiceEvent): Defines callback path operation. Includes body and response models. Path can use OpenAPI 3 expressions with request parameters. @app.post(\"/invoices/\", callbacks=invoices_callback_router.routes) def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None): Main API endpoint, uses callbacks parameter to document external API. Example: callback_url = \"https://example.com/api/v1/invoices/events/\" httpx.post(callback_url, json={\"description\": \"Invoice paid\", \"paid\": True}) OpenAPI Webhooks define server initiated requests. FastAPI documents webhooks in OpenAPI 3.1.0+. Use @app.webhooks.post(name) to define webhook handler. Example: @app.webhooks.post(\"event_name\") def handler(body: Model):. Webhook names are identifiers not paths. Models can be defined using Pydantic BaseModel. Path Operation Advanced Configuration. OpenAPI operationId: set operation_id in path operation. operation_id: str. Use function name as operationId: use_route_names_as_operation_ids(app: FastAPI). Exclude from OpenAPI: include_in_schema=False. Advanced description from docstring: use \\f to truncate docstring for OpenAPI. openapi_extra: extend OpenAPI schema for path operation. Example: @app.get(\"/items/\", openapi_extra={\"x-aperture-labs-portal\": \"blue\"}). Custom OpenAPI path operation schema: use openapi_extra to define requestBody schema. Custom OpenAPI content type: use openapi_extra to define requestBody content type, e.g., \"application/x-yaml\". Response: Allows overriding default status codes. Status code can be set using `response.status_code`. Example: `@app.put(\"/get-or-create-task/{task_id}\", status_code=200) def get_or_create_task(task_id: str, response: Response): response.status_code = status.HTTP_201_CREATED` Response Cookies: Use Response parameter in path operation to set cookies. Example: from fastapi import FastAPI, Response; app = FastAPI(); @app.post(\"/cookie-and-object/\") def create_cookie(response: Response): response.set_cookie(key=\"fakesession\", value=\"fake-cookie-session-value\"); return {\"message\": \"Come to the dark side, we have cookies\"}. Return Response directly: Create a response, set cookies, return it. Example: from fastapi import FastAPI, Response, JSONResponse; app = FastAPI(); @app.post(\"/cookie/\") def create_cookie(): content = {\"message\": \"Come to the dark side, we have cookies\"}; response = JSONResponse(content=content); response.set_cookie(key=\"fakesession\", value=\"fake-cookie-session-value\"); return response. FastAPI uses starlette.responses. Return a Response Directly: Return Response or subclass (e.g., JSONResponse) from path operation. FastAPI won't modify it. Use jsonable_encoder to convert data to JSON-compatible types before putting in a Response. Example: from fastapi import FastAPI, Response; app = FastAPI(); @app.get(\"/legacy/\") def get_legacy_data(): data = \"<xml><data>...</data></xml>\"; return Response(content=data, media_type=\"application/xml\") Response Headers. Use Response parameter: get_headers(response: Response): response.headers[\"X-Cat-Dog\"] = \"alone in the world\". Return Response directly: return JSONResponse(content=content, headers=headers). Custom Headers: use 'X-' prefix. CORS configurations needed for browser visibility: expose_headers. HTTP Basic Auth: Implements HTTP Basic Authentication. HTTPBasic(): Creates a security scheme for HTTP Basic Auth. HTTPBasicCredentials: Object containing username and password. security = HTTPBasic(): Initializes HTTP Basic security scheme. @app.get(\"/users/me\"): Path operation secured with HTTP Basic Auth. def read_current_user(credentials: Annotated[HTTPBasicCredentials, Depends(security)]): Requires valid HTTP Basic credentials. secrets.compare_digest(a, b): Securely compares strings to prevent timing attacks. HTTPException(status_code=401, detail=\"Incorrect username or password\", headers={\"WWW-Authenticate\": \"Basic\"}): Returns 401 error with WWW-Authenticate header. def get_current_username(credentials: Annotated[HTTPBasicCredentials, Depends(security)]): Dependency to validate username and password. Advanced Security features build upon Tutorial - User Guide: Security. Token: access_token str token_type str TokenData: username str | None = None scopes list[str] = [] User: username str email str | None = None full_name str | None = None disabled bool | None = None UserInDB: hashed_password str pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") oauth2_scheme = OAuth2PasswordBearer( tokenUrl=\"token\" scopes={\"me\": \"Read information about the current user.\" \"items\": \"Read items.\"}) app = FastAPI() def verify_password(plain_password hashed_password) def get_password_hash(password) def get_user(db username str) -> UserInDB: if username in db: user_dict = db[username] def authenticate_user(fake_db username str password str) -> bool: user = get_user(fake_db username) if not user: if not verify_password(password user.hashed_password): def create_access_token(data dict expires_delta timedelta | None = None) -> str: to_encode = data.copy() if expires_delta: expire = datetime.now(timezone.utc) + expires_delta else: expire = datetime.now(timezone.utc) + timedelta(minutes=15) to_encode.update({\"exp\": expire}) encoded_jwt = jwt.encode(to_encode SECRET_KEY algorithm=ALGORITHM) def get_current_user(security_scopes SecurityScopes token: Annotated[str Depends(oauth2_scheme)]) -> UserInDB: if security_scopes.scopes: authenticate_value = f'Bearer scope=\"{security_scopes.scope_str}\"' else: authenticate_value = \"Bearer\" credentials_exception = HTTPException(status_code=status.HTTP_401_UNAUTHORIZED detail=\"Could not validate credentials\" headers={\"WWW-Authenticate\": authenticate_value}) try: payload = jwt.decode(token SECRET_KEY algorithms=[ALGORITHM]) username: str = payload.get(\"sub\") if username is None: raise credentials_exception token_scopes = payload.get(\"scopes\" []) token_data = TokenData(scopes=token_scopes username=username) except (InvalidTokenError ValidationError): raise credentials_exception user = get_user(fake_users_db username=token_data.username) if user is None: raise credentials_exception for scope in security_scopes.scopes: if scope not in token_data.scopes: raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED detail=\"Not enough permissions\" headers={\"WWW-Authenticate\": authenticate_value}) return user def get_current_active_user(current_user: Annotated[User Security(get_current_user scopes=[\"me\"])]) -> User: if current_user.disabled: raise HTTPException(status_code=400 detail=\"Inactive user\") return current_user @app.post(\"/token\") async def login_for_access_token(form_data: Annotated[OAuth2PasswordRequestForm Depends()] -> Token: user = authenticate_user(fake_users_db form_data.username form_data.password) if not user: raise HTTPException(status_code=400 detail=\"Incorrect username or password\") access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES) access_token = create_access_token(data={\"sub\": user.username \"scopes\": form_data.scopes} expires_delta=access_token_expires) return Token(access_token=access_token token_type=\"bearer\") @app.get(\"/users/me/\" response_model=User) async def read_users_me(current_user: Annotated[User Depends(get_current_active_user)]) -> User: return current_user @app.get(\"/users/me/items/\") async def read_own_items(current_user: Annotated[User Security(get_current_active_user scopes=[\"items\"])]) -> list: return [{\"item_id\": \"Foo\" \"owner\": current_user.username}] @app.get(\"/status/\") async def read_system_status(current_user: Annotated[User Depends(get_current_user)]) -> dict: return {\"status\": \"ok\"} Settings: app_name: str, admin_email: str, items_per_user: int. BaseSettings subclass for app configuration using environment variables. get_settings() -> Settings. Dependency to retrieve settings, cached with @lru_cache. info(settings: Settings) -> dict. Returns app info using settings. Supports .env files via model_config = SettingsConfigDict(env_file=\".env\"). Mount independent FastAPI sub-applications. app.mount(\"/subapi\", subapi). Example: from fastapi import FastAPI app = FastAPI() @app.get(\"/app\") def read_main(): return {\"message\": \"Hello World from main app\"} subapi = FastAPI() @subapi.get(\"/sub\") def read_sub(): return {\"message\": \"Hello World from sub API\"} app.mount(\"/subapi\", subapi). Each app has independent OpenAPI and docs UIs. FastAPI handles root_path for sub-applications automatically. Use any template engine (e.g., Jinja2). Install: pip install jinja2. Jinja2Templates(directory=\"templates\"). templates.TemplateResponse(name, request=request, context={}). Example: from fastapi import FastAPI, Request from fastapi.templating import Jinja2Templates app = FastAPI() templates = Jinja2Templates(directory=\"templates\") @app.get(\"/items/{id}\", response_class=HTMLResponse) async def read_item(request: Request, id: str): return templates.TemplateResponse(request=request, name=\"item.html\", context={\"id\": id}). Templates at templates/item.html. Use {{ id }} to render context values. Use url_for('path_operation', id=id) for URLs. Check Starlette's docs for details. Testing Dependencies: Override dependencies during testing using app.dependency_overrides. Example: app.dependency_overrides[original_dependency] = override_dependency. Reset overrides: app.dependency_overrides = {}. Set/reset overrides within test functions for specific tests. from fastapi import Depends, FastAPI; from fastapi.testclient import TestClient; app = FastAPI(); async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return {\"q\": q, \"skip\": skip, \"limit\": limit}; @app.get(\"/items/\") async def read_items(commons: dict = Depends(common_parameters)): return {\"message\": \"Hello Items!\", \"params\": commons}; client = TestClient(app); async def override_dependency(q: str | None = None): return {\"q\": q, \"skip\": 5, \"limit\": 10}; app.dependency_overrides[common_parameters] = override_dependency; def test_override_in_items(): response = client.get(\"/items/\"); assert response.status_code == 200 Testing Events: startup - shutdown. Test event handlers using TestClient with a with statement. TestClient(app) context manager runs startup and shutdown events. Example: with TestClient(app) as client: client.get(\"/items/foo\"). TestClient for testing WebSockets. Use client.websocket_connect(url) to connect. Methods: websocket.receive_json() -> dict, websocket.send_json(data: dict), websocket.close(). Example: with client.websocket_connect(\"/ws\") as websocket: data = websocket.receive_json(). Requires Starlette. Access Request object directly for unvalidated data. from fastapi import FastAPI, Request. @app.get(\"/items/{item_id}\") def read_root(item_id: str, request: Request): client_host = request.client.host; return {\"client_host\": client_host, \"item_id\": item_id}. FastAPI passes Request object to parameter of type Request. Other parameters are still validated. See Starlette documentation for Request details. WebSockets: Install: pip install websockets. @app.websocket(path) async def endpoint(websocket: WebSocket): await websocket.accept() data = await websocket.receive_text() await websocket.send_text(f\"Message: {data}\") Use Depends, Security, Cookie, Header, Path, Query. WebSocketException: Raise instead of HTTPException for WebSockets. ConnectionManager: connect(websocket: WebSocket): adds websocket to active connections. disconnect(websocket: WebSocket): removes websocket. send_personal_message(message: str, websocket: WebSocket): sends message to one websocket. broadcast(message: str): sends to all connected websockets. WebSocketDisconnect: Raised when connection closes. Handle with try/except. WSGIMiddleware: Mount WSGI apps (Flask, Django). `from fastapi.middleware.wsgi import WSGIMiddleware`. `app.mount(path, WSGIMiddleware(wsgi_app))`. Example: Flask at /v1, FastAPI at /v2. FastAPI supports async/await for path operation functions. Use async def with await for I/O-bound operations. Use def for CPU-bound ops or if unsure. FastAPI handles both asynchronously. Concurrency is for I/O waiting; parallelism for CPU tasks. Coroutines are from async def. def functions run in threadpool. FastAPI can be deployed on various cloud providers. Some providers sponsor FastAPI's development. Deployment Concepts: Security (HTTPS, TLS proxy). Startup (Docker, Kubernetes, Systemd). Restarts (on failure). Replication (worker processes for concurrency, memory per process). Previous steps (init scripts, migrations). Resource utilization (CPU, RAM). Deploy FastAPI in Linux containers using Docker. Dockerfile example: FROM python:3.9; WORKDIR /code; COPY ./requirements.txt /code/requirements.txt; RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt; COPY ./app /code/app; CMD [\"fastapi\", \"run\", \"app/main.py\", \"--port\", \"80\"]. Use exec form for CMD. Optimize Dockerfile by copying requirements first to leverage caching. Use --proxy-headers behind TLS Termination Proxy. Deployment concepts: HTTPS, startup, restarts, replication, memory. Use multiple containers (e.g., Kubernetes) or single containers with multiple processes. Deprecated base image: tiangolo/uvicorn-gunicorn-fastapi. Use uv Docker guide with uv. HTTPS requires certificates from a third party, which expire and need renewal. Encryption happens at the TCP level, before HTTP. SNI extension allows multiple HTTPS certificates on a single IP. TLS Termination Proxy (e.g., Traefik, Caddy, Nginx, HAProxy) manages HTTPS, decrypts requests, and encrypts responses. Let's Encrypt provides free certificates. Example: Browser resolves domain to IP via DNS, TLS handshake with SNI selects certificate, encrypted HTTP communication follows. Certificate renewal must prove domain ownership, possibly using DNS records or running a server. HTTPS is important; understand concepts for easy configuration. Deployment: Make app available to users via remote machine and server program. Server Workers - Uvicorn with Workers. Use multiple workers for deployment. fastapi run --workers [num] or uvicorn main:app --workers [num]. --workers: CLI option to start worker processes for parallel execution and handle more requests. Parent process manages worker processes. FastAPI versions: Use 0.x.x, potential breaking changes. Pin fastapi version in requirements.txt: fastapi[standard]==0.112.0 or fastapi[standard]>=0.112.0,<0.113.0. See available versions in Release Notes. PATCH versions are for bug fixes, MINOR versions add breaking changes. Add tests for your app, then upgrade FastAPI version. Don't pin starlette version. Pydantic >=1.0.0 is compatible. FastAPI Features: OpenAPI, automatic data model documentation, interactive API docs (Swagger UI, ReDoc), based on standard Python type declarations, editor support, validation, security/authentication, dependency injection, Starlette compatibility, Pydantic compatibility. FastAPI: Web framework for building APIs with Python type hints. High performance, fast to code, production ready. app = FastAPI(): Creates a FastAPI application. @app.get(\"/\"): Defines a GET path operation for the root path. async def read_root(): Can be used with async def for asynchronous operations. @app.get(\"/items/{item_id}\"): Path with a parameter item_id. def read_item(item_id: int, q: Union[str, None] = None): item_id is a path parameter, q is an optional query parameter. class Item(BaseModel): Defines a request body model with Pydantic. @app.put(\"/items/{item_id}\"): PUT operation with a path parameter and request body. def update_item(item_id: int, item: Item): Updates an item. fastapi dev main.py: Runs the FastAPI app with Uvicorn, auto-reloads on changes. Dependencies: Starlette, Pydantic. Installation: pip install \"fastapi[standard]\". Full Stack FastAPI Template: FastAPI backend, SQLModel ORM, Pydantic validation, PostgreSQL DB, React frontend, TypeScript, Chakra UI, auto frontend client, Playwright tests, Docker Compose, HTTPS, JWT auth, email recovery, GitHub Actions CI/CD. Python Type Hints used by FastAPI for validation and documentation. Basic types: str, int, float, bool, bytes. Generic types from typing: List[type], Tuple[types], Set[type], Dict[key_type, value_type], Union[types], Optional[type], Annotated[type, metadata]. Function parameter type hint: def func(param: type) -> return_type:. Pydantic BaseModel uses type hints for data validation: class Model(BaseModel): field: type."